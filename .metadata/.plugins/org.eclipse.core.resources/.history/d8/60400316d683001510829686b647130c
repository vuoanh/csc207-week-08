package edu.grinnell.sortingvisualizer.sorts;

import java.util.ArrayList;

import edu.grinnell.sortingvisualizer.sortevents.CompareEvent;
import edu.grinnell.sortingvisualizer.sortevents.CopyEvent;
import edu.grinnell.sortingvisualizer.sortevents.SortEvent;
import edu.grinnell.sortingvisualizer.sortevents.SwapEvent;

public class Sorts{
	/* Given a list of SortEvent objects and an array of Ts, 
	 * applies those events to the array in-order. */
	public <T> void eventSort(ArrayList<SortEvent> eventList, T[] arr){
		int arrLength = arr.length;
		int listSize = eventList.size();
		for(int i = 0; i < listSize; i++){
			eventList.get(i).apply(arr);
		}
	}

	public static <T extends Comparable<? super T>> ArrayList<SortEvent> BubbleSort(T[] arr){
		ArrayList<SortEvent> bubbleList = new ArrayList<SortEvent>(); 
		if (arr == null) {
			throw new IllegalArgumentException();
		}
		int k = 0;
		for (int i = arr.length; i >= 0; i--) {
			for (int j = 0 ; j < i - 1; j++) {
				k = j + 1;
				SortEvent<T> compareEvent = new CompareEvent<T>(bubbleList,k, j);
				if (arr[k].compareTo(arr[j]) < 0) {
					SortEvent<T> swapEvent = new SwapEvent<T>(arr, bubbleList,k,j);
				}
			}
		}
		return bubbleList;
	}

	public static <T extends Comparable<? super T>> ArrayList<SortEvent> InsertionSort(T arr[]){
		ArrayList<SortEvent> insertList = new ArrayList<SortEvent>(); 
		for(int i = 0; i < arr.length-1; i++){
			for(int j = i+1; j > 0; j--){
				SortEvent<T> compareEvent = new CompareEvent<T>(insertList,j, j-1);
				// compare event
				if(arr[j].compareTo(arr[j-1]) <0){
					// swap jth and (j-1)th element of the list
					SortEvent<T> swapEvent = new SwapEvent<T>(arr, insertList,j, j-1);
				} else break;
			}
		}
		return insertList;
	}

	public static <T extends Comparable<? super T>> void merge(T[] arr, int leftPos, 
		int rightPos, T outArr[], int rightEnd, ArrayList<SortEvent> mergeList){
		int leftEnd = rightPos - 1;
		int tmpPos = leftPos;
		// Compare first element of each of left and right sub arrays.
		// Copy the smaller element to outArr
		while(leftPos <= leftEnd && rightPos <= rightEnd){
			ArrayList<Integer> compareIndArr = new ArrayList<Integer>();
			SortEvent<T> compareEvent = new CompareEvent<T>(mergeList, leftPos, rightPos);
			// compare Event
			if (arr[leftPos].compareTo(arr[rightPos]) < 0){
				outArr[tmpPos++] = arr[leftPos++];
			}
			else {
				outArr[tmpPos++] = arr[rightPos++];
			}
		}
		// if right sub array is out of element
		while(leftPos <= leftEnd){
			outArr[tmpPos++] = arr[leftPos++];
		}
		while(rightPos <= rightEnd){
			outArr[tmpPos++] = arr[rightPos++];
		}
		// Copy outArr back to arr
		for(int i = 0; i < arr.length; i++){
			//copy event
			ArrayList<Integer> copyIndArr = new ArrayList<Integer>();
			copyIndArr.add(i);
			SortEvent<T> copyEvent = new CopyEvent<T>(mergeList,i,outArr[i]);
			mergeList.add(copyEvent);
			//copy event : arr[i] = outArr[i];
			copyEvent.apply(arr);
		}
	}
	/* Helper mergeSort for mergeSort method. 
	 * Recursively devide the array into left and right sub arrays
	 * Then, recursively merge left and right sub arrays by using merge method
	 *  */
	public static <T extends Comparable<? super T>> ArrayList<SortEvent> mergeSortHelper(T arr[], int lower, 
			int upper){
		ArrayList<SortEvent> mergeList = new ArrayList<SortEvent>();
		T[] tmpArr = (T[]) new Comparable[arr.length];
		if (upper > lower) {
			int mid = lower + (upper - lower) /2;
			int leftPos = lower;
			int rightPos = mid + 1;
			int leftEnd = rightPos -1;
			int rightEnd = upper;
			int tmpPos = leftPos;
			mergeSortHelper(arr, lower, mid);
			mergeSortHelper(arr, mid+1, upper);
			//merge(arr, lower, mid + 1, tmpArr, upper);
			//merge(int[] arr, int leftPos, int rightPos, int outArr[], int rightEnd){
				//int ElementNum = rightEnd - leftPos +1;
				//int leftEnd = rightPos - 1;
				//int tmpPos = leftPos;

			
			
			
			// Compare first element of each of left and right sub arrays.
			// Copy the smaller element to outArr
			while(leftPos <= leftEnd && rightPos <= rightEnd){
				ArrayList<Integer> compareIndArr = new ArrayList<Integer>();
				compareIndArr.add(leftPos);
				compareIndArr.add(rightPos);
				SortEvent<T> compareEvent = new CompareEvent<T>(compareIndArr);
				mergeList.add(compareEvent);
				// compare Event
				if (arr[leftPos].compareTo(arr[rightPos]) < 0){
					tmpArr[tmpPos++] = arr[leftPos++];
				}
				else {
					tmpArr[tmpPos++] = arr[rightPos++];
				}
			}
			// if right sub array is out of element
			while(leftPos <= leftEnd){
				tmpArr[tmpPos++] = arr[leftPos++];
			}
			while(rightPos <= rightEnd){
				tmpArr[tmpPos++] = arr[rightPos++];
			}
			// Copy outArr back to arr
			for(int i = 0; i < arr.length; i++){
				//copy event
				ArrayList<Integer> copyIndArr = new ArrayList<Integer>();
				copyIndArr.add(i);
				SortEvent<T> copyEvent = new CopyEvent<T>(copyIndArr, tmpArr[i]);
				mergeList.add(copyEvent);
				//copy event : arr[i] = outArr[i];
				copyEvent.apply(arr);
			}
		}
		return mergeList;
	}
	public static <T extends Comparable<? super T>> ArrayList<SortEvent> mergeSort(T arr[]){
		in N = a
		return mergeSortHelper(arr, 0, arr.length-1);
	}

	private static ArrayList<SortEvent> quickList;

	public static <T extends Comparable<? super T>> T[] BaseSort(T arr[], int left, int right){
		for(int i = left; i < right; i++){
			for(int j = i+1; j > left; j--){
				ArrayList<Integer> compareIndArr = new ArrayList<Integer>();
				compareIndArr.add(j);
				compareIndArr.add(j-1);
				SortEvent<T> compareEvent = new CompareEvent<T>(compareIndArr);
				quickList.add(compareEvent);
				if(arr[j].compareTo(arr[j-1]) < 0){

					// swap event
					ArrayList<Integer> indArr = new ArrayList<Integer>();
					indArr.add(j);
					indArr.add(j-1);
					SortEvent<T> swapEvent = new SwapEvent<T>(indArr);
					swapEvent.apply(arr);
					quickList.add(swapEvent);
				} else break;
			}
		}
		return arr;
	}

	public static <T extends Comparable<? super T>> ArrayList<SortEvent> quickSort(T[] arr){
		QuickSortHelper(arr, 0, arr.length-1);
		return quickList;
	}

	public static <T extends Comparable<? super T>> void QuickSortHelper(T arr[],int left, int right){
		if(left >= right - 2){ //when there's no more than three elements in left
			BaseSort(arr, left, right); //sort the remaining array of length three
		}
		else {
			T pivot;
			int middle = (left + right)/2;
			//creating pivot according to finding median of first, middle, and last
			// compare Event
			ArrayList<Integer> compareIndArr = new ArrayList<Integer>();
			compareIndArr.add(right);
			compareIndArr.add(left);
			SortEvent<T> compareEvent = new CompareEvent<T>(compareIndArr);
			quickList.add(compareEvent);
			if(arr[right].compareTo(arr[left]) < 0){
				ArrayList<Integer> indArr = new ArrayList<Integer>();
				indArr.add(right);
				indArr.add(left);
				SortEvent<T> swapEvent = new SwapEvent<T>(indArr);
				swapEvent.apply(arr);
				quickList.add(swapEvent);
			}
			ArrayList<Integer> compareIndArr1 = new ArrayList<Integer>();
			compareIndArr.add(right);
			compareIndArr.add(left);
			SortEvent<T> compareEvent1 = new CompareEvent<T>(compareIndArr1);
			quickList.add(compareEvent1);
			// compare Event
			if(arr[left].compareTo(arr[middle]) < 0){
				ArrayList<Integer> indArr = new ArrayList<Integer>();
				indArr.add(left);
				indArr.add(middle);
				SortEvent<T> swapEvent = new SwapEvent<T>(indArr);
				swapEvent.apply(arr);
				quickList.add(swapEvent);
			}
			ArrayList<Integer> compareIndArr2 = new ArrayList<Integer>();
			compareIndArr.add(middle);
			compareIndArr.add(left);
			SortEvent<T> compareEvent2 = new CompareEvent<T>(compareIndArr2);
			quickList.add(compareEvent2);
			// compare Event
			if(arr[middle].compareTo(arr[right]) < 0){
				ArrayList<Integer> indArr = new ArrayList<Integer>();
				indArr.add(right);
				indArr.add(middle);
				SortEvent<T> swapEvent = new SwapEvent<T>(indArr);
				swapEvent.apply(arr);
				quickList.add(swapEvent);
			}
			pivot = arr[middle];

			//swap event
			ArrayList<Integer> indArr = new ArrayList<Integer>();
			indArr.add(middle);
			indArr.add(right);
			SortEvent<T> swapEvent = new SwapEvent<T>(indArr);
			swapEvent.apply(arr);
			quickList.add(swapEvent);
			//bc "right" is greater than middle, 
			//swap middle to the index before right to create pivot
			//go through array and swap
			//i = low && j = high
			int i = left;
			int j = right;
			while(i < j){
				//increments i until it is untrue (fixes i to an index)
				while(arr[++i].compareTo(pivot) < 0){
					//decrements j until it is untrue (fixes j to an index)
					while(arr[--j].compareTo(pivot) > 0); 
					if(i >= j){
						break; //stop the "pointers"
					}
					// swap event
					ArrayList<Integer> indArr1 = new ArrayList<Integer>();
					indArr.add(i);
					indArr.add(j);
					SortEvent<T> swapEvent1 = new SwapEvent<T>(indArr1);
					swapEvent.apply(arr);
					quickList.add(swapEvent1);
				}
				// swap event
				ArrayList<Integer> indArr2 = new ArrayList<Integer>();
				indArr.add(right);
				indArr.add(i);
				SortEvent<T> swapEvent2 = new SwapEvent<T>(indArr2);
				swapEvent.apply(arr);
				quickList.add(swapEvent2);
				QuickSortHelper(arr, left, i-1);
				QuickSortHelper(arr, i+1, right);
			}
		}
	}

	public static<T extends Comparable<? super T>> ArrayList<SortEvent> SelectionSort(T[] arr){
		ArrayList<SortEvent> selectionList = new ArrayList<SortEvent>();
		int length = arr.length;
		int i, j, pos, temp;
		for (i = 0; i < length - 1; i++) {
			pos = i;
			for(j = i+1; j < length; j++){
				ArrayList<Integer> indArr = new ArrayList<Integer>();
				indArr.add(j);
				indArr.add(pos);
				SortEvent<T> compareEvent = new CompareEvent<T>(indArr);
				compareEvent.apply(arr);
				selectionList.add(compareEvent);
				if(arr[j].compareTo(arr[pos]) < 0){
					pos = j;
				}
			}
			// swap event
			ArrayList<Integer> indSwapArr = new ArrayList<Integer>();
			indSwapArr.add(i);
			indSwapArr.add(pos);
			SortEvent<T> swapEvent = new SwapEvent<T>(indSwapArr);
			swapEvent.apply(arr);
			selectionList.add(swapEvent);
		}
		return selectionList;

	}

}

